<!DOCTYPE html>
<html lang="en">
   <head>
      <!-- basic -->
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <!-- mobile metas -->
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="viewport" content="initial-scale=1, maximum-scale=1">
      <!-- site metas -->
      <title>ECE 5160 Portfolio By Zechen</title>
      <meta name="keywords" content="">
      <meta name="description" content="">
      <meta name="author" content="">
      <!-- bootstrap css -->
      <link rel="stylesheet" href="css/bootstrap.min.css">
      <!-- style css -->
      <link rel="stylesheet" href="css/style.css">
      <!-- Responsive-->
      <link rel="stylesheet" href="css/responsive.css">
      <!-- fevicon -->
      <link rel="icon" href="images/fevicon.png" type="image/gif" />
      <!-- Scrollbar Custom CSS -->
      <link rel="stylesheet" href="css/jquery.mCustomScrollbar.min.css">
      <!-- Tweaks for older IEs-->
      <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.css" media="screen">
      <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script><![endif]-->
   </head>
   <!-- body -->
   <body class="main-layout">
      <!-- loader  -->
<!--       <div class="loader_bg">
         <div class="loader"><img src="images/loading.gif" alt="#" /></div>
      </div> -->
      <!-- end loader --> 
      <!-- header -->
      <header>
         <!-- header inner -->
         <div class="header">
         <div class="container">
            <div class="row">
               <div class="col-xl-6 col-lg-3 col-md-3 col-sm-3 col logo_section">
                  <div class="full">
                     <div class="center-desk">
                        <div class="logo"> <a href="index.html">ECE 5160 Fast Robot</a> </div>
                     </div>
                  </div>
               </div>
               <div class="col-xl-6 col-lg-9 col-md-9 col-sm-9">
                  <div class="menu-area">
                     <div class="limit-box">
                        <nav class="main-menu">
                           <ul class="menu-area-main">
                              <li class="active"> <a href="#">Home</a> </li>
                              <li> <a href="#about">About</a> </li>
                              <li> <a href="#labs">Lab Reports</a> </li>
                              <li> <a href="#pics">Gallery</a> </li>
                           </ul>
                        </nav>
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <!-- end header inner --> 
      </header>
      <!-- end header -->
<!-- about  -->
      <div id="about" class="about">
         <div class="container">
            <div class="row">
               <div class="col-md-12">
                  <div class="titlepage">
                     <h2>About</h2>
                        <span>
                              This website is the portfolio for the course ECE 5160: Fast Robot at Cornell University, Spring 2023 <br>
                              Instructor: Prof. Kirstin Petersen<br><br>
                              <img class="img-rounded" src="assets/profile.png" alt="profile image" style="width:25%;"><br>
                              Hey! My name is Zechen Wang, an MEng student in the ECE Department. <br>
                              I got my bachelor's degree in Computer Engineering and Computer Science at USC,<br>
                              and I am really interested in embedded systems, robotics, and IoT devices. Contact me at &ltzw652&gt!<br><br>


                              <em>This site is still under construction.<br>Maybe you'll see something prettier next time!</em>
                              <a href="https://cei-lab.github.io/FastRobots-2023/" target="_blank">Course Website</a>
                              <a href="https://github.com/zechenwang00/ECE-5160-Sp23" target="_blank">Github Repo</a>
                        </span>
                  </div>
               </div>
            </div>
         </div>
      </div>
      <!-- end abouts -->

<!-- service --> 
      <div id="labs" class="service">
         <div class="container">
            <div class="row">
               <div class="col-md-12">
                  <div class="titlepage">
                     <h2>Labs </h2>
                     <div>
                             <details>
                             <summary style="text-align:left;font-weight: bold; color:#fc4311;font-size: 24px;text-decoration:underline;">Lab 1: Setup</summary>
<!--                              <h3 style="text-align:left;font-weight: bold; color:#fc4311;">Lab 1</h3> -->
                             <h4 style="text-align:left;font-weight: bold;"><br>Introduction</h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    This lab is the first assignment aimed to let students set up and become familiar with the Arduino IDE and 
                                    the hardware component Artemis Nano which we will be using throughout the semester. The tasks in this lab 
                                    assignment include reading relevant datasheets, configuring the IDE, compiling and uploading programs to 
                                    the board, and performing tests on the board by viewing outputs from the serial interface.<br>
                                    <em>Note: This lab assignment also includes the 5000-level tasks.<br><br></em>
                                 </p>
                              <h4 style="text-align:left;font-weight: bold;">Example I: Blink</h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    The first demonstrable result is to have the Artemis Nano board loaded with an example blink program, and
                                    to verify the LED blinking. The example blinking program has one single function of toggling an onboard LED 
                                    every 450 miliseconds (900ms as a period). The results have been recorded in the following video: <br>
                                    <br><br>
                                 </p>
                                 <video width=60%; controls>
                                    <source src="assets/lab1/blink.mp4" type=video/mp4>
                                 </video><br><br>
                              <h4 style="text-align:left;font-weight: bold;">Example II: Serial</h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    In this part of the lab, we load program the board using a serial communication example code and test the 
                                    interface on Arduino IDE. The program first prints out several debug messages and then proceeds to enter a 
                                    echo mode, which simply sends whatever message the board receives back to the PC. In the following video, 
                                    we could see that two messages "new msg" and "test2" were succesfully sent to the Artemis board and echoed 
                                    back to the serial interface.<br><br>
                                 </p>
                                 <video height=640px; controls>
                                    <source src="assets/lab1/serial.mp4" type=video/mp4>
                                 </video><br><br> 
                              <h4 style="text-align:left;font-weight: bold;">Example III: Temperature</h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    The third part of this lab is to test the functionality of the internal temperature sensor on the Artemis 
                                    board. After loading an example temperature reading program, we could directly fetch the readings from the
                                    temperature sensor through an serial interface which we tested in the previous part. The process of changing 
                                    the temperature was taking a considerable amount of time, as I was simply using my hands to transfer some heat. 
                                    From the video below, you could see the readings from the temperature sensor increasing slowly. 
                                    (you may want to fast forward a little bit!)<br><br>
                                 </p>
                                 <video height=640px; controls>
                                    <source src="assets/lab1/temp.mp4" type=video/mp4>
                                 </video><br><br>
                              <h4 style="text-align:left;font-weight: bold;">Example IV: Microphone</h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    The last part of this lab is to test the microphone on the Artemis board. A microphone testing example program
                                    is provided to print out the strongest audio signal in the frequency spectrum. The program will sample from the
                                    microphone, perform a fast Fourier transform(FFT), and then pick out the signal with the highest intensity. <br><br>
                                    For the 5000-level task, the program should also behave as an electronic tuner, that responds to musical "A" notes. 
                                    Specifically, my program would respond to "A" notes in different octaves(A1 to A8), but due to environmental noise 
                                    I could only demonstrate some of them (A4, A5, A6). In addition, I found out that the program will freeze entirely 
                                    when a delay function is used to toggle the LED. To solve that, I implemented a non-blocking LED blinking mechanism 
                                    by reading time from the internal clock, so that the program would simply check if the LED should be toggled during 
                                    every iteration in the main loop.<br><br>
                                 </p>
                                 <video height=640px; controls>
                                    <source src="assets/lab1/mic.mp4" type=video/mp4>
                                 </video><br><br>
                                 <pre>
                                    <code>
// non-blocking delay LED blinker reference: https://docs.arduino.cc/built-in-examples/digital/BlinkWithoutDelay
// full program included in github repo, Lab1 folder

if (currentMillis - previousMillis >= interval) {
   previousMillis = currentMillis;
   digitalWrite(LED_BUILTIN, LOW);
}
                                    </code> 
                                 </pre>
                              </details>


                             <details>
                             <summary style="text-align:left;font-weight: bold; color:#fc4311;font-size: 24px;text-decoration:underline;">Lab 2: BLE</summary>
<!--                              <h3 style="text-align:left;font-weight: bold; color:#fc4311;">Lab 2</h3> -->
                             <h4 style="text-align:left;font-weight: bold;"><br><u>Introduction</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    This lab includes various tasks related to the use of bluetooth to establish connection between the Artemis 
                                    board and our computer. On the Artemis side, we would need to modify the .ino files in order to implement 
                                    customized commands which can be processed on board. On the pc side, we need to design software handlers which 
                                    processes different kinds of information sent back from the artemis board, extracts useful information, and 
                                    formats output. After implementing and testing various functions/commands, we will also test the efficiency 
                                    and reliability of data transmission by sending data packets of various sizes. (5000-level assignment)
                                 </p>
                                 <img class="img-rounded" src="assets/lab2/BLE.png" alt="BLE image" style="width:20%; text-align: center;"><br>
                              <h4 style="text-align:left;font-weight: bold;"><u>Prelab</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    Before starting to work on any of the lab tasks, we want to make sure we can establish a stable connection between 
                                    the BLE device and our PC. First we want to copy the hardware MAC address of our device, and generate a unique 
                                    identifier to be placed in a configuration file. Change the first two lines in the following file:
                                 </p>
                                 <br>
                                 <img class="img-rounded" src="assets/lab2/settings.png" alt="settings image" style="width:50%;"><br>
                                 <figcaption style="font-size: 16px;"><em>connection settings on PC</em></figcaption>
                                 <br>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    Then we will be ready for the connection! After establishing the connection, the Artemis side and the PC side will 
                                    work together to transmit/receive information. How a typical task will be done is: <br><br>
                                    1. PC sends command to Artemis<br>
                                    2. Artemis receives command and does some processing<br>
                                    3. Artemis send data back to PC<br>
                                    4. PC process or display data<br>
                                 </p>
                              <h4 style="text-align:left;font-weight: bold;"><br><u>Jupyter Notebook</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                 <a href="assets/lab2/zechen_lab2.ipynb" download target="_blank" style="color:blue"><u>click to download file</u></a>
                                 </p>
                              <h4 style="text-align:left;font-weight: bold;"><br><u>Task 1: Echo Command</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    Echo command simply lets Artemis echo back a message from the PC. We first need to send an echo command with a payload string 
                                    to Artemis. After receiving the string, Artemis replies back the same string to the PC. While on the PC side, we woud need to 
                                    call a function to receive such string and print it to the console. <br><br>
                                    In the below output, we want to first verify that the Artemis board was successfully connected to our PC by confirming the mac 
                                    address and a 'PONG' reply to our PING command. After that, we send a 'hi' to the Artemis board, and confirmed an echo message 
                                    both on the Artemis board and on the PC console.<br><br>
                                 </p>
                                 <div class="row" style="text-align: center;">
                                   <div class="column2">
                                     <img src="assets/lab2/step1_nano.png" alt="s1nano" style="width:80%">
                                     <figcaption style="font-size: 16px;"><em>serial output from Artemis</em></figcaption>
                                   </div>
                                   <div class="column2">
                                     <img src="assets/lab2/step1_pc.png" alt="s1pc" style="width:100%">
                                     <figcaption style="font-size: 16px;"><em>sending and receiving data on PC</em></figcaption>
                                   </div>
                                 </div>
                              <h4 style="text-align:left;font-weight: bold;"><br><u>Task 2: Get Time</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    For the second task, we want to implement a command <em>GET_TIME_MILLIS</em> which lets the Artemis read the current time from 
                                    its clock on board (miliseconds since boot up) and send that number back to the PC as a string. We frist want to do it without 
                                    any function handlers, meaning that we will manually send and receive the string to verify it working properly.<br><br>
                                    <b>On the Artemis side</b>, we need to implement a function to format the current time into a string for transmission. The code snippet 
                                    for such function is attatched below to the left. After sending the command from the PC, we could also verify the string via the 
                                    serial interface (screenshot on the lower right).
                                    <br><br>
                                 </p>
                                 <div class="row" style="text-align: center;">
                                   <div class="column2">
                                     <img src="assets/lab2/step2_nano_code.png" alt="s2nanocode" style="width:100%">
                                     <figcaption style="font-size: 16px;"><em>code snippet of GET_TIME_MILLIS on Artemis</em></figcaption>
                                   </div>
                                   <div class="column2">
                                     <img src="assets/lab2/step2_nano.png" alt="s2nano" style="width:60%">
                                     <figcaption style="font-size: 16px;"><em>serial output from Artemis</em></figcaption>
                                   </div>
                                 </div>
                                 <br>

                                 <p style="text-align: left;padding: 0px 30px;">
                                    <b>On the PC side</b>, we would need to send the command we just created, and then manually receive the time string with a receive_string 
                                    command. We could automate this process in the subsequent steps.
                                    <br><br>
                                 </p>
                                 <img class="img-rounded" src="assets/lab2/step2_pc.png" alt="step2pc" style="width:60%";><br>
                                 <figcaption style="font-size: 16px;"><em>sending and receiving time string on PC</em></figcaption>
                                 <br>

                              <h4 style="text-align:left;font-weight: bold;"><br><u>Task 3: Notification Handler</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                 By setting up a notification handler function, we would be able to automate the receiving and processing procedure every time after sending 
                                 a command. Specifically, we want to define a function that will be called whenever we receive a string from the PC side. Then we use the 
                                 start_notify function in BLE to automatically trigger the function we just defined whenever a new string is received. In this case, our function 
                                 simply decodes the byte array into a string and then interpret the time by splitting it at the ":" character.
                                 <br><br>
                                 </p>
                                 <img class="img-rounded" src="assets/lab2/step3_pc.png" alt="step3pc" style="width:50%";><br>
                                 <figcaption style="font-size: 16px;"><em>defining and using callback functions</em></figcaption>
                                 <br><br>

                              <h4 style="text-align:left;font-weight: bold;"><br><u>Task 4: Get Temperature Command</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                 In this section we would want to implement functions to request temperature data on the Artemis board. First we would like to sample 5 times 
                                 within five seconds, then we proceed to sample for the entire five seconds without any stopping.<br><br>
                                 <b>On the Artemis side</b>, we need to implement a function to sample five times upon receving the request. The results would be formatted into 
                                 a string for transmission with pairs of timestamp and temperature data. The following code snippet to the left is the function implemented in 
                                 arduino, and the output screenshot to the right shows the actual output string being transmitted to PC.
                                 </p>
                                 <br><br>

                                 <div class="row" style="text-align: center;">
                                   <div class="column2">
                                     <img src="assets/lab2/step4_nano_code.png" alt="s4nanocode" style="width:80%">
                                     <figcaption style="font-size: 16px;"><em>code snippet of GET_TIME_MILLIS on Artemis</em></figcaption>
                                   </div>
                                   <div class="column2">
                                     <img src="assets/lab2/step4_nano.png" alt="s4nano" style="width:100%">
                                     <figcaption style="font-size: 16px;"><em>serial output from Artemis</em></figcaption>
                                   </div>
                                 </div>
                                 <br>

                                 <p style="text-align: left;padding: 0px 30px;">
                                    <b>On the PC side</b>, we would like to keep what we have done in the previous task -- use a callback function to automatically receive and 
                                    process strings from Artemis. Specifically, we split each pair of data by the "|" separator, and then further separate time and temperature 
                                    by the ":" separator. After extracting the useful information, we print them to the console. A code snippet and an example processed output will 
                                    be included in the following screenshot.
                                 </p>
                                 <br>
                                 <img class="img-rounded" src="assets/lab2/step4_pc.png" alt="step4pc" style="width:50%";><br>
                                 <figcaption style="font-size: 16px;"><em>callback and output for temperature reading</em></figcaption>
                                 <br>

                              <h4 style="text-align:left;font-weight: bold;"><br><u>Task 5: Rapid Temperature reading</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                 This section is very similar to the previous one. The only difference is that we would sample many more times in the 5 seconds interval (at least 
                                 50 times). The code snippet of Artemis is included below, which is a minimally modified version of the previous function.
                                 <br><br>
                                 </p>
                                 <img class="img-rounded" src="assets/lab2/step5_nano_code.png" alt="step5nanocode" style="width:50%";><br>
                                 <figcaption style="font-size: 16px;"><em>rapid sampling code</em></figcaption>
                                 <br> 
                                 <p style="text-align: left;padding: 0px 30px;">
                                 Then we use the same callback function to receive the rapid readings. We got many of them and some are included below:
                                 <br><br>
                                 </p>
                                 <div class="row" style="text-align: center;">
                                   <div class="column2">
                                     <img src="assets/lab2/step5_pc_1.png" alt="s5pc1" style="width:60%">
                                     <figcaption style="font-size: 16px;"><em>processed output - 1</em></figcaption>
                                   </div>
                                   <div class="column2">
                                     <img src="assets/lab2/step5_pc_2.png" alt="s5pc2" style="width:40%">
                                     <figcaption style="font-size: 16px;"><em>processed output - 2</em></figcaption>
                                   </div>
                                 </div>                             
                              <h4 style="text-align:left;font-weight: bold;"><br><u>Task 6: Limitations</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                 The Artemis board has 384 kB (384,000 bytes) RAM, which is quite limited for data processing if we are always dealing with long strings of data.
                                 Assuming that 100% of the RAM are available for our use, and we are sampling 16-bit (2 bytes) data at a rate of 150Hz for 5 seconds during each interval.
                                 We would generate data size of 2 * 150 * 5 = 1500 Bytes for every interval, which is 1/256 of our total RAM.<br><br>
                                 <b>In other words, we would be able to collect and store 256 groups of such data in the RAM, which is equivalent to 1280 seconds of data collection
                                 before running out of memory.</b>
                                 </p>
                                 <br>
                              <h4 style="text-align:left;font-weight: bold;"><br><u>Extra Task 1: Effective Data Rate</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                 We could calculate the data rate by sending and receiving data with various sizes. For my implementation, I simply used the ECHO command to send strings 
                                 of sizes from 1 to 120 characters. The effective data rate will be calculated by (transmission time - received time) / 2 * data size. Code snippet and 
                                 visualization of the calculated data will be included below:
                                 </p>
                                 <br>                                 
                                 <div class="row" style="text-align: center;">
                                   <div class="column2">
                                     <img src="assets/lab2/E1_1.png" alt="e11" style="width:100%">
                                     <figcaption style="font-size: 16px;"><em>Code for data collection</em></figcaption>
                                   </div>
                                   <div class="column2">
                                     <img src="assets/lab2/E1_2.png" alt="e12" style="width:100%">
                                     <figcaption style="font-size: 16px;"><em>visualization of results</em></figcaption>
                                   </div>
                                 </div>
                                 <br>
                                 <p style="text-align: left;padding: 0px 30px;">
                                  One point I found important is that, in order for the callback function to correctly document data transmission time, we need to append transmission and 
                                  receiving time in lists and calculate the difference later. If we were to use a shared global variable for time calculation, it may be difficult to 
                                  ensure that every timestamp being read in the callback function corresponds to the message's respective transmission time.<br><br>
                                  My observation is that the transmission time is independent from string size: no matter what size of data we transmit, latency is always about the same. 
                                  Maybe smaller packets have larger overheads relative to its acutal payload size, and larger packets have smaller portions of overhead. My conclusion is that sending larger packets will yield larger effective data rate.
                                 </p>
                                 <br>
                              <h4 style="text-align:left;font-weight: bold;"><br><u>Extra Task 2: Reliability</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                 Reliability is assessed by rapidly sending packets from Artemis and trying to receive them on the PC side. By manually setting the delay interval to 0 in 
                                 the arduino code, we could try to send 1000 packets as fast as we can. From the following screenshot, we can confirm 100% reliability since all packets has 
                                 been received.
                                 </p>
                                 <br>
                                 <div class="row" style="text-align: center;">
                                   <div class="column2">
                                     <img src="assets/lab2/E2_code.png" alt="e2code" style="width:100%">
                                     <figcaption style="font-size: 16px;"><em>Code for sending 1k packets</em></figcaption>
                                   </div>
                                   <div class="column2">
                                     <img src="assets/lab2/E2.png" alt="e2" style="width:100%">
                                     <figcaption style="font-size: 16px;"><em>reliability calculation</em></figcaption>
                                   </div>
                                 </div>    

                              </details>

                              <details>
                              <summary style="text-align:left;font-weight: bold; color:#fc4311;font-size: 24px;text-decoration:underline;">Lab 3: TOF</summary>
                                 <h4 style="text-align:left;font-weight: bold;"><br><u>Introduction</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    This lab assignment require students to complete a set of hardware and software related tasks. We would first connect the TOF sensors to our Artemis Nano
                                    board, confirm using example codes, and then write our own programs for data collection. With these tasks completed, we will be more prepared for any 
                                    future tasks that require I2C sensor connections and data transmission via bluetooth.
                                 </p>
                                 <br>
                              <h4 style="text-align:left;font-weight: bold;"><br><u>Prelab</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    As included in the datasheet and in the header file <em>SparkFun_VL53L1X.h</em>, the default I2C address of the TOF sensors we are using is <b>0x52</b>.
                                    Using this address wouldn't cause any problem when there is only one such TOF device connected to our system. However, if we want to use multiple TOF 
                                    sensors, or in the future, integrate more sensors into our system, we would need to manually change their I2C address to avoid conflict. Since the I2C 
                                    protocol specifies that the master will communicate to the slave devices using their respecive addresses, we want to set each of the I2C device's address
                                    to an arbitrary and fixed address. <br><br>
                                    My approach of solving the I2C conflict between two TOF sensors is to manually disable one of them using the XSHUT pin, change the second one's address, 
                                    and enable the first sensor again. That way my <em>setI2Caddress</em> function will only affect one of the sensors. <br><br>
                                    For the placement of sensors, since we only have two TOF sensors. I would like to place one facing the front, and the other facing the left side. Still, 
                                    in cases where an obstacle appears to the right or to the back, we would not be able to detect it. Also for angles around 45 degrees and near the front, I
                                    am uncertain if the two sensors will be able to detect obstacles.
                                 </p>
                                 <br>
                                 <img class="img-rounded" src="assets/lab3/schematic.jpg" alt="schematic" style="width:30%";><br>
                                 <figcaption style="font-size: 16px;"><em>hardware connections schematic</em></figcaption>
                                 <br>

                              <h4 style="text-align:left;font-weight: bold;"><br><u>Task 1: Connecting Hardware</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    The following picture demonstrate the actual hardware setup of my system, followed by a screenshot showing a I2C address scan on Artemis.
                                 </p>
                                 <br>
                                 <img class="img-rounded" src="assets/lab3/hw_connection.jpg" alt="hw" style="width:40%";><br>
                                 <figcaption style="font-size: 16px;"><em>hardware connection</em></figcaption>
                                 <br>
                                 <img class="img-rounded" src="assets/lab3/i2c_addr.png" alt="i2c_addr" style="width:40%";><br>
                                 <figcaption style="font-size: 16px;"><em>I2C address</em></figcaption>
                                 <br>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    We could see from the above serial message that there are two devices detected. By manually disconnecting the hardware components, I found out 
                                    that the 0x69 device is the IMU, and the 0x29 device is the TOF sensor.<br><br>This is a very interesting result, since the TOF sensor, by default 
                                    should have an address of 0x52. Looking into the bitwise representations of each address, we could find out that 0x29 is 0010_1001, while 0x52 0101_0010. 
                                    Looks like the address scanning example ignored the 0 at LSB, and consequently right shifted the address by 1 bit. Furthermore, we can't be sure if the 
                                    IMU actually has the address 0x69 or (0x69 << 1) = 0xD2.
                                 </p>
                                 <br>

                              <h4 style="text-align:left;font-weight: bold;"><br><u>Task 2: Sampling from TOF</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    The three modes provided are short, medium, and long distance mode. According to the VL53L1X datasheet, the short mode is more immune to ambience light,
                                    which will have better performance in noisy or unpredictable envrionments. Since we may suffer more from ambience light conditions as we increase the 
                                    maximum distance, and 1.3m should be quite enough for detecting obstacles/walls, I would like to choose the short distance mode. Following is a 
                                    demonstration of how testing data was acquired, and a visualizaiton of such data using the short distance mode. 

                                 </p>
                                 <br>
                                 <div class="row" style="text-align: center;">
                                   <div class="column2">
                                     <img src="assets/lab3/measurement_setup.jpg" alt="measuresetup" style="width:80%">
                                     <figcaption style="font-size: 16px;"><em>measurement setup</em></figcaption>
                                   </div>
                                   <div class="column2">
                                     <img src="assets/lab3/measure.png" alt="measure" style="width:86%">
                                     <figcaption style="font-size: 16px;"><em>visualization of data</em></figcaption>
                                   </div>
                                 </div>
                                 <br>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    In this setup, the TOF sensor was temporarily attatched to a surface to make sure it is perpendicular to the ground. It was elevated from ground 
                                    during data collection so that it was less likely to be affected by surface reflections from the desk. After repeating collection at various distance, 
                                    I collected a group of ~10 data points and visualized it using matplotlib. We could see from the plot that the measured distances was closer to the 
                                    actual distances for smaller values (<400), and start to have slightly larger errors for values > 400. <br><br>
                                    Overall, the errors are within a 10% margin, and could be negligible depending on what task we are doing. There could also be systematic errors caused
                                    by my experiment setup which led to such error margin. In conclusion, I would say the short distance mode TOF would be reliable enough for my future labs.

                                 </p>
                                 <br>  


                              <h4 style="text-align:left;font-weight: bold;"><br><u>Task 3: Connecting Multiple Sensors</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    First, we would like to slightly modify the provided example code to let it support multiple sensors. The major task here is to manually set a different
                                    I2C address for one of the TOF sensors, otherwise two of them would be sending/receiving at the same time. The sensor setup code to the left includes how 
                                    the address change was done: send a LOW signal to XSHUT on TOF1 to disable it --> set new address for TOF2 --> send a HIGH signal to XSHUT on TOF1 to 
                                    enable it. <br><br>
                                    The sampling code to the right shows how sampling was done for multiple sensors. We would like to make sure both sensors have data ready before actually 
                                    fetching them. So we would loop and check data availability while printing out time information. (that way we don't simply leave it waiting!)
                                 </p>
                                 <br>
                                 <div class="row" style="text-align: center;">
                                   <div class="column2">
                                     <img src="assets/lab3/multi_setup.png" alt="multisetup" style="width:80%">
                                     <figcaption style="font-size: 16px;"><em>Two sensor setup code</em></figcaption>
                                   </div>
                                   <div class="column2">
                                     <img src="assets/lab3/multi_code.png" alt="multicode" style="width:100%">
                                     <figcaption style="font-size: 16px;"><em>Two sensor sampling code</em></figcaption>
                                   </div>
                                 </div>
                                 <br>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    Following are the outputs from Artemis, one with time info printed to serial and the other doesn't. We could use the time information to determine how
                                    long it took for Artemis to do different tasks. When Artemis is simply waiting for data, time is being printed to serial evey 1 milisecond. We can observe
                                    a ~10 ms delay before and after each sensor output, suggesting that data collection, sending control signals, and formatting output roughly takes 
                                    10 ms. The interval between each group of data is around 55ms.<br><br>
                                    In other words, if data is always available, we would be able to see each group of output at around 18Hz. The inter-measurement period may also be reduced 
                                    by using its API. According to the documentation, it could theoretically sample as fast as every 20ms, which ups the sampling rate to 50Hz.
                                 </p>
                                 <br>
                                 <div class="row" style="text-align: center;">
                                   <div class="column2">
                                    <img class="img-rounded" src="assets/lab3/multi_w_time.png" alt="multiwtime" style="width:40%";><br>
                                    <figcaption style="font-size: 16px;"><em>Artemis output for two TOF sensors with timestamps</em></figcaption>
                                   </div>
                                   <div class="column2">
                                    <img class="img-rounded" src="assets/lab3/multi.png" alt="multi" style="width:60%";><br>
                                    <figcaption style="font-size: 16px;"><em>Artemis output for two TOF sensors</em></figcaption>
                                   </div>
                                 </div>

                                 <br>

                              <h4 style="text-align:left;font-weight: bold;"><br><u>Task 4: Data Transmission via Bluetooth</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    This section describes how data is transmitted from Artemis to PC via Bluetooth and then processed. Starting from the results on PC, we can see 
                                    on the left that we are reusing some code pieces from lab 2. Using a callback function for interpreting the timestamps and TOF readings, we simply 
                                    need to request TOF data multiple(50) times to collect enough data for visualization. On the right, we simply use matplotlib to plot both TOF readings 
                                    respective to time. The data was collected when I was moving hands in front of both sensors, so we can see that both readings are changing in similar 
                                    patterns.
                                 </p>
                                 <br>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    <a href="assets/lab3/zechen_lab3.ipynb" download target="_blank" style="color:blue"><u>click to download jupyter notebook</u></a>
                                 </p>
                                 <br>
                                 <div class="row" style="text-align: center;">
                                   <div class="column2">
                                    <img class="img-rounded" src="assets/lab3/multi_BLE_code.png" alt="multiBLE" style="width:80%";><br>
                                    <figcaption style="font-size: 16px;"><em>receiving and processing data on PC</em></figcaption>
                                   </div>
                                   <div class="column2">
                                    <img class="img-rounded" src="assets/lab3/multi_BLE_plot.png" alt="multiBLEplot" style="width:100%";><br>
                                    <figcaption style="font-size: 16px;"><em>receiving and processing data on PC</em></figcaption>
                                   </div>
                                 </div>   
                                 <br>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    Then we can proceed to see how the code was implemented on the Artemis side. The left screenshot is the serial output from Artemis, showing that it 
                                    is sending one string at a time encoding a timestamp and two TOF readings. To the right, we can find similar content compared to previous sections, 
                                    the difference is that, after reading data, we not only print them to serial, but also transmit them via BLE connection. There are also BLE configurations
                                    that need to be done before transmission -- those are similar to lab2 tasks and could be referenced from there.
                                 </p>
                                 <br>
                                 <div class="row" style="text-align: center;">
                                   <div class="column2">
                                     <img src="assets/lab3/multi_BLE_nano.png" alt="multiBLEnano" style="width:60%">
                                     <figcaption style="font-size: 16px;"><em>Artemis output with timestamp</em></figcaption>
                                   </div>
                                   <div class="column2">
                                     <img src="assets/lab3/multi_BLE_nano_code.png" alt="multiBLEnanocode" style="width:100%">
                                     <figcaption style="font-size: 16px;"><em>Artemis code snippet</em></figcaption>
                                   </div>
                                 </div>   

                              <h4 style="text-align:left;font-weight: bold;"><br><u>Task 5: Discussion of Envrionmental Factors</u></h4>
                                 <p style="text-align: left;padding: 0px 30px;">
                                    Placeholder
                                 </p>
                                 <br>

                             </details>


<!--                          <img class="img-rounded" src="images/penguin.jpg" alt="Generic placeholder image" style="width:20%; text-align: center;"><br>
                              <p>Placeholder image</p> -->
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </div>
      <!-- end service -->
      <!--  footer --> 
      <footr>
         <div class="footer">
<!--             <div class="container">
               <div class="row">
                  <div class="col-lg-2 col-md-6 col-sm-12 width">
                     <div class="address">
                        <h3>Address</h3>
                        <i><img src="icon/3.png">Locations</i>
                     </div>
                  </div>
                  <div class="col-lg-2 col-md-6 col-sm-12 width">
                     <div class="address">
                        <h3>Menus</h3>
                        <i><img src="icon/2.png">Locations</i>
                     </div>
                  </div>
                  <div class="col-lg-2 col-md-6 col-sm-12 width">
                     <div class="address">
                        <h3>Useful Linkes</h3>
                        <i><img src="icon/1.png">Locations</i>
                     </div>
                  </div>
                  <div class="col-lg-2 col-md-6 col-sm-12 width">
                     <div class="address">
                        <h3>Social Media </h3>
                        <ul class="contant_icon">
                           <li><img src="icon/fb.png" alt="icon"/></li>
                           <li><img src="icon/tw.png" alt="icon"/></li>
                           <li><img src="icon/lin(2).png" alt="icon"/></li>
                           <li><img src="icon/instagram.png" alt="icon"/></li>
                        </ul>
                     </div>
                  </div>
                  <div class="col-xl-3 col-lg-3 col-md-12 col-sm-12 width">
                     <div class="address">
                        <h3>Newsletter </h3>
                        <input class="form-control" placeholder="Enter your email" type="type" name="Enter your email">
                        <button class="submit-btn">Subscribe</button>
                     </div>
                  </div>
               </div>
            </div> -->
            <div class="copyright">
               <p>Copyright 2019 All Right Reserved By <a href="https://html.design/">Free html Templates</a>, modified by Zechen Wang</p>
            </div>
         </div>
      </footr>
      <!-- end footer -->
      <!-- Javascript files--> 
      <script src="js/jquery.min.js"></script> 
      <script src="js/popper.min.js"></script> 
      <script src="js/bootstrap.bundle.min.js"></script> 
      <script src="js/jquery-3.0.0.min.js"></script> 
      <script src="js/plugin.js"></script> 
      <!-- sidebar --> 
      <script src="js/jquery.mCustomScrollbar.concat.min.js"></script> 
      <script src="https:cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.js"></script>
      <script src="js/custom.js"></script>
      <script>
         $(document).ready(function(){
         $(".fancybox").fancybox({
         openEffect: "none",
         closeEffect: "none"
         });
         
         $(".zoom").hover(function(){
         
         $(this).addClass('transition');
         }, function(){
         
         $(this).removeClass('transition');
         });
         });
         
      </script> 
   </body>
</html>